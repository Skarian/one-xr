diff --git a/src/imu_reader.py b/src/imu_reader.py
index 7884a8c..0ef5719 100644
--- a/src/imu_reader.py
+++ b/src/imu_reader.py
@@ -19,12 +19,15 @@ TIMEOUT = 5
 
 # Protocol constants
 HEADER = bytes.fromhex("283600000080")
+ALT_HEADER = bytes.fromhex("273600000080")
+HEADERS = (HEADER, ALT_HEADER)
 FOOTER = bytes.fromhex("000000cff753e3a59b0000db34b6d782de1b43")
 SENSOR_MSG = bytes.fromhex("00401f000040")
 
 # Protocol data offsets
 DATA_START_OFFSET = 20  # timestamp(8) + invariant(2) + static(10)
 DATA_END_OFFSET = -26   # sensor_msg(6) + date_info(20)
+IMU_FLOAT_BYTES = 24
 
 class IMUReader:
     def __init__(self, ip: str = IP, port: int = PORT, timeout: int = TIMEOUT, 
@@ -80,21 +83,40 @@ class IMUReader:
 
     def process_message(self, message):
         """Process raw message and extract IMU data"""
-        if len(message) < len(HEADER) + 8 + len(FOOTER) + 31:
+        header = None
+        for candidate in HEADERS:
+            if message.startswith(candidate):
+                header = candidate
+                break
+        if header is None:
             return None
-            
-        # Remove header, session ID (8 bytes), footer, and tail (31 bytes)
-        data = message[len(HEADER) + 8:-len(FOOTER) - 31]
-        
-        if not data.endswith(SENSOR_MSG):
+
+        min_len = len(header) + 8 + DATA_START_OFFSET + IMU_FLOAT_BYTES + len(SENSOR_MSG)
+        if len(message) < min_len:
             return None
-        
-        # Extract IMU data section
-        if len(data) < DATA_START_OFFSET + abs(DATA_END_OFFSET):
+
+        data = message[len(header) + 8:]
+        sensor_pos = data.find(SENSOR_MSG)
+        if sensor_pos == -1 or sensor_pos < DATA_START_OFFSET + IMU_FLOAT_BYTES:
             return None
-            
-        data = data[DATA_START_OFFSET:DATA_END_OFFSET]
-        return self.decode_imu_data(data.hex())
+
+        imu_data = data[DATA_START_OFFSET:sensor_pos]
+        if len(imu_data) < IMU_FLOAT_BYTES:
+            return None
+
+        return self.decode_imu_data(imu_data[:IMU_FLOAT_BYTES].hex())
+
+    def _find_header(self, buffer: bytes, start: int = 0):
+        earliest_pos = -1
+        earliest_header = None
+        for header in HEADERS:
+            pos = buffer.find(header, start)
+            if pos == -1:
+                continue
+            if earliest_pos == -1 or pos < earliest_pos:
+                earliest_pos = pos
+                earliest_header = header
+        return earliest_pos, earliest_header
 
     def connect(self):
         """Establish TCP connection"""
@@ -124,18 +146,20 @@ class IMUReader:
 
                     # Process complete messages
                     while True:
-                        header_pos = recv_buffer.find(HEADER)
+                        header_pos, header = self._find_header(recv_buffer, 0)
                         if header_pos == -1:
                             break
-                            
-                        footer_pos = recv_buffer.find(FOOTER, header_pos)
-                        if footer_pos == -1:
+
+                        if header_pos > 0:
+                            recv_buffer = recv_buffer[header_pos:]
+                            header_pos = 0
+
+                        next_header_pos, _ = self._find_header(recv_buffer, len(header))
+                        if next_header_pos == -1:
                             break
 
-                        # Extract complete message
-                        message_end = footer_pos + len(FOOTER)
-                        message = recv_buffer[header_pos:message_end]
-                        recv_buffer = recv_buffer[message_end:]
+                        message = recv_buffer[:next_header_pos]
+                        recv_buffer = recv_buffer[next_header_pos:]
 
                         # Process message and get IMU data
                         imu_data = self.process_message(message)
